/* -*- c-basic-offset: 4 indent-tabs-mode: nil -*- vi:set ts=8 sts=4 sw=4: */

/*
    Rosegarden
    A MIDI and audio sequencer and musical notation editor.
    Copyright 2000-2009 the Rosegarden development team.

    Other copyrights also apply to some parts of this work.  Please
    see the AUTHORS file and individual file headers for details.

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License as
    published by the Free Software Foundation; either version 2 of the
    License, or (at your option) any later version.  See the file
    COPYING included with this distribution for more information.
*/


/*                         Qt4.3 List of Stylable Widgets                    */

/*  QAbstractScrollArea.

Supports the box model. All derivatives of QAbstractScrollArea, including
QTextEdit, and QAbstractItemView (all item view classes), support scrollable
backgrounds using background-attachment. Setting the background-attachment to
fixed provides a background-image that does not scroll with the viewport.
Setting the background-attachment to scroll, scrolls the background-image when
the scroll bars move.  See Customizing QAbstractScrollArea for an example. */

QAbstractScrollArea {
/* May have to use some caution here, Ã  la QWidget, because setting this
 * background currently overrides the white background in the notation editor in
 * the qt4-graphicsview branch, making the notation editor quite unusable. */
/*    background-color: #000000; 
    color: #FFFFFF; */
}


/*  QCheckBox

Supports the box model. The check indicator can be styled using the ::indicator
subcontrol. By default, the indicator is placed in the Top Left corner of the
Contents rectangle of the widget.  The spacing property specifies the spacing
between the check indicator and the text. */

QCheckBox {
}


/*  QColumnView

The grip can be styled be using the image property. The arrow indicators can by
styled using the ::left-arrow subcontrol and the ::right-arrow subcontrol. */

QColumnView {
}


/*  QComboBox

The frame around the combobox can be styled using the box model. The drop-down
button can be styled using the ::drop-down subcontrol. By default, the
drop-down button is placed in the top right corner of the padding rectangle of
the widget. The arrow mark inside the drop-down button can be styled using the
::down-arrow subcontrol. By default, the arrow is placed in the center of the
contents rectangle of the drop-down subcontrol. */

/* pasted example code again */
QComboBox {
    border: 1px solid gray;
    border-radius: 3px;
    padding: 1px 18px 1px 3px;
    min-width: 6em;
}

QComboBox:editable {
    background: white;
}

QComboBox:!editable, QComboBox::drop-down:editable {
     background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
                                 stop: 0 #E1E1E1, stop: 0.4 #DDDDDD,
                                 stop: 0.5 #D8D8D8, stop: 1.0 #D3D3D3);
}

/* QComboBox gets the "on" state when the popup is open */
QComboBox:!editable:on, QComboBox::drop-down:editable:on {
    background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
                                stop: 0 #D3D3D3, stop: 0.4 #D8D8D8,
                                stop: 0.5 #DDDDDD, stop: 1.0 #E1E1E1);
}

QComboBox:on { /* shift the text when the popup opens */
    padding-top: 3px;
    padding-left: 4px;
}

QComboBox::drop-down {
    subcontrol-origin: padding;
    subcontrol-position: top right;
    width: 15px;

    border-left-width: 1px;
    border-left-color: darkgray;
    border-left-style: solid; /* just a single line */
    border-top-right-radius: 3px; /* same radius as the QComboBox */
    border-bottom-right-radius: 3px;
}

QComboBox::down-arrow {
    image: url(/usr/share/icons/crystalsvg/16x16/actions/1downarrow.png);
}

QComboBox::down-arrow:on { /* shift the arrow when popup is open */
    top: 1px;
    left: 1px;
}

/* The pop-up of the QComboBox is a QAbstractItemView and is styled using the
descendant selector: */

QComboBox QAbstractItemView {
    border: 2px solid darkgray;
    selection-background-color: lightgray;
}


/*  QDateEdit   See QSpinBox.
    QDateTimeEdit   See QSpinBox. */


/*  QDialog

Supports only the background, background-clip and background-origin properties.
If you subclass from QDialog, you need to provide a paintEvent for your custom
QDialog as below:

void CustomDialog::paintEvent(QPaintEvent *) {
    QStyleOption opt;
    opt.init(this);
    QPainter p(this);
    style()->drawPrimitive(QStyle::PE_Widget, &opt, &p, this);
}

The above code is a no-operation if there is no stylesheet set.
Warning: Make sure you define the Q_OBJECT macro for your custom widget. */

QDialog {
    background: #101010;
}


/*  QDialogButtonBox 

  The layout of buttons can be altered using the button-layout property. */

QDialogButtonBox {
/*    background: #949494; */
}


/*  QDoubleSpinBox   See QSpinBox. */


/*  QFrame

Supports the box model.  Since 4.3, setting a stylesheet on a QLabel
automatically sets the QFrame::frameStyle property to QFrame::StyledPanel. */

QFrame {
    /* We probably want these to remain invisible, and not style them.  If there
     * are exceptions, they'll have to be addressed on a case by case basis,
     * because styling QFrame in general is definitely a BAD idea */
}


/*  QGroupBox

Supports the box model. The title can be styled using the ::title subcontrol.
By default, the title is placed depending on QGroupBox::textAlignment.  In the
case of a checkable QGroupBox, the title includes the check indicator. The
indicator is styled using the the ::indicator subcontrol. The spacing property
can be used to control the spacing between the text and indicator. */

QGroupBox {
   background-color: #808080;
   color: white;
   border: 2px solid #2CD0FC;
   border-radius: 4px;
   padding: 2px;
}


/*  QHeaderView 

Supports the box model. The sections of the header view are styled using the
::section sub control. The section Sub-control supports the :middle, :first,
:last, :only-one, :next-selected, :previous-selected, :selected pseudo states.
Sort indicator in can be styled using the ::up-arrow and the ::down-arrow
Sub-control. */

QHeaderView {
}


/*  QLabel
 
Supports the box model. Does not support the :hover pseudo-state.  Since 4.3,
setting a stylesheet on a QLabel automatically sets the QFrame::frameStyle
property to QFrame::StyledPanel. */

QLabel {
    /* we don't want to specify a background color for QLabel, because we use
     * them in many different places that should have different backgrounds, but
     * putting a background in for now makes it easier to see all the places
     * that are affected by this change. */
    /* background-color: blue; */
    color: #ABCDEF;
}


/*  QLineEdit

Supports the box model.  The color and background of the selected item is styled
using selection-color and selection-background-color respectively.  The password
character can be styled using the lineedit-password-character property. */

QLineEdit {
}


/*  QListView (affects QListWidget)
  
Supports the box model. When alternating row colors is enabled, the alternating
colors can be styled using the alternate-background-color property.  The color
and background of the selected item is styled using selection-color and
selection-background-color respectively.  The selection behavior is controlled
by the #show-decoration-selected-prop property.  See QAbsractScrollArea to style
scrollable backgrounds. */

QListView {
}


/*  QMenu
  
Supports the box model.  Individual items are styled using the ::item
subcontrol. In addition to the usually supported pseudo states, item subcontrol
supports the :selected, :default, :exclusive and the non-exclusive pseudo
states.  The indicator of checkable menu items is styled using the ::indicator
subcontrol.  The separator is styled using the ::separator subcontrol.  For
items with a sub menu, the arrow marks are styled using the right-arrow and
left-arrow.  The scroller is styled using the ::scroller.  The tear-off is
styled using the ::tear-off. */

QMenu {
    background-color: #000000;
}

QMenu::item {
    /* sets background of menu item. set this to something non-transparent
       if you want menu color and menu item color to be different */
    background-color: transparent;
    color: #FFFFFF;
}

QMenu::item:selected { /* when user selects item using mouse or keyboard */
    background-color: #2CD0FC;
}




/*  QMenuBar
  
Supports the box model. The spacing property specifies the spacing between menu
items. Individual items are styled using the ::item subcontrol. */

QMenuBar {
    background-color: #454545;
}

QMenuBar::item {
    spacing: 3px; /* spacing between menu bar items */
    padding: 1px 4px;
    background: transparent;
    border-radius: 4px;
    font: bold;
    color: white;
}

QMenuBar::item:selected { /* when selected using mouse or keyboard */
    background: #0088E8;
}

QMenuBar::item:pressed {
    background: #2CD0FC;
}


/*  QMessageBox
  
The messagebox-text-interaction-flags property can be used to alter the
interaction with text in the message box. */

QMessageBox {
    background: #949494;
}



/*  QProgressBar
  
Supports the box model. The chunks of the progress bar can be styled using the
::chunk subcontrol. The chunk is displayed on the Contents rectangle of the
widget.  If the progress bar displays text, use the text-align property to
position the text.  Indeterminate progress bars have the :indeterminate pseudo
state set. */

QProgressBar {
}


/*  QPushButton
 
Supports the box model. Supports the :default, :flat, :checked pseudo states.
For QPushButton with a menu, the menu indicator is styled using the ::menu-indicator subcontrol. Appearance of checkable push buttons can be customized using the :open and :closed pseudo-states. */

QPushButton {
    border: 1px solid #AAAAAA;
    border-radius: 6px;
    background-color: #808080;
/*    background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
                                       stop: 0 #f6f7fa, stop: 1 #dadbde); 
    min-width: 80px; */
}




/*  QRadioButton

Supports the box model. The check indicator can be styled using the ::indicator
subcontrol. By default, the indicator is placed in the Top Left corner of the
Contents rectangle of the widget.  The spacing property specifies the spacing
between the check indicator and the text. */

QRadioButton {
}



/*  QScrollBar

Supports the box model. The Contents rectangle of the widget is considered to be
the groove over which the slider moves. The extent of the QScrollBar (i.e the
width or the height depending on the orientation) is set using the width or
height property respectively. To determine the orientation, use the :horizontal
and the :vertical pseudo states.  The slider can be styled using the ::handle
subcontrol. Setting the min-width or min-height provides size contraints for the
slider depending on the orientation.  The ::add-line subcontrol can be used to
style the button to add a line. By default, the add-line subcontrol is placed in
top right corner of the Border rectangle of the widget. Depending on the
orientation the ::right-arrow or ::down-arrow. By default, the arrows are placed
in the center of the Contents rectangle of the add-line subcontrol.  The
::sub-line subcontrol can be used to style the button to subtract a line. By
default, the sub-line subcontrol is placed in bottom right corner of the Border
rectangle of the widget. Depending on the orientation the ::left-arrow or
::up-arrow. By default, the arrows are placed in the center of the Contents
rectangle of the sub-line subcontrol.  The ::sub-page subcontrol can be used to
style the region of the slider that subtracts a page. The ::add-page subcontrol
can be used to style the region of the slider that adds a page. */

QScrollBar {
}

/* horizontal scrollbars */
QScrollBar:horizontal {
    border: 2px solid grey;
    background: #32CC99;
    height: 15px;
    margin: 0px 20px 0 20px;
}

QScrollBar::handle:horizontal {
    background: white;
    min-width: 20px;
}

QScrollBar::add-line:horizontal {
    border: 2px solid grey;
    background: #32CC99;
    width: 20px;
    subcontrol-position: right;
    subcontrol-origin: margin;
}

QScrollBar::sub-line:horizontal {
    border: 2px solid grey;
    background: #32CC99;
    width: 20px;
    subcontrol-position: left;
    subcontrol-origin: margin;
}

/* vertical scrollbars */
QScrollBar:vertical {
    border: 2px solid grey;
    background: #32CC99;
    width: 15px;
    margin: 22px 0 22px 0;
}

QScrollBar::handle:vertical {
    background: white;
    min-height: 20px;
}

QScrollBar::add-line:vertical {
    border: 2px solid grey;
    background: #32CC99;
    height: 20px;
    subcontrol-position: bottom;
    subcontrol-origin: margin;
}

QScrollBar::sub-line:vertical {
    border: 2px solid grey;
    background: #32CC99;
    height: 20px;
    subcontrol-position: top;
    subcontrol-origin: margin;
}

QScrollBar::up-arrow:vertical, QScrollBar::down-arrow:vertical {
    border: 2px solid grey;
    width: 3px;
    height: 3px;
    background: white;
}

QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical {
    background: none;
}


/*  QSizeGrip

Supports the width, height, and image properties. */

QSizeGrip {
}


/*  QSlider

Supports the box model. For horizontal slides, the min-width and height
properties must be provided. For vertical sliders, the min-height and width
properties must be provided.  The groove of the slider is styled using the
::groove. The groove is positioned by default in the Contents rectangle of the
widget. The thumb of the slider is styled using ::handle subcontrol. The
subcontrol moves in the Contents rectangle of the groove subcontrol. */

/* boilerplate code pasted from styling example
 *
 * this actually looks a lot better than the stock default, though this is by no
 * means a suggestion for what it should ultimately look like */

QSlider::groove:horizontal {
    border: 1px solid #999999;
    height: 8px; /* the groove expands to the size of the slider by default. by giving it a height, it has a fixed size */
    background: qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #B1B1B1, stop:1 #c4c4c4);
    margin: 2px 0;
}

QSlider::handle:horizontal {
    background: qlineargradient(x1:0, y1:0, x2:1, y2:1, stop:0 #b4b4b4, stop:1 #8f8f8f);
    border: 1px solid #5c5c5c;
    width: 18px;
    margin: -2px 0; /* handle is placed by default on the contents rect of the groove. Expand outside the groove */
    border-radius: 3px;
}

/* what is this green white pink stuff?  doesn't seem to be visible.  anyway,
 * this is just boilerplate code pasted from an example */
QSlider::groove:vertical {
    background: red;
    position: absolute; /* absolutely position 4px from the left and right of the widget. setting margins on the widget should work too... */
    left: 4px; right: 4px;
}

QSlider::handle:vertical {
    height: 10px;
    background: green;
    margin: 0 -4px; /* expand outside the groove */
}

QSlider::add-page:vertical {
    background: white;
}

QSlider::sub-page:vertical {
    background: pink;
}



/*  QSpinBox
  
The frame of the spin box can be styled using the box model.  The up button and
arrow can be styled using the ::up-button and ::up-arrow subcontrols. By
default, the up-button is placed in the top right corner in the Padding
rectangle of the widget. Without an explicit size, it occupies half the height
of its reference rectangle. The up-arrow is placed in the center of the Contents
rectangle of the up-button.  The down button and arrow can be styled using the
::down-button and ::down-arrow subcontrols. By default, the down-button is
placed in the bottom right corner in the Padding rectangle of the widget.
Without an explicit size, it occupies half the height of its reference
rectangle. The bottom-arrow is placed in the center of the Contents rectangle of
the bottom-button. */

QSpinBox {
}


/*  QSplitter

Supports the box model. The handle of the splitter is styled using the ::handle
subcontrol. */

QSplitter {
}


/*  QStatusBar

Supports only the background property. The frame for individual items can be
style using the ::item subcontrol. */

QStatusBar {
}



/*  QTabBar
  
Individual tabs may be styled using the ::tab subcontrol. The tabs support the
:only-one, :first, :last, :middle, :previous--selected, :next-selected,
:selected pseudo states.  The :top, :left, :right, :bottom pseudo states
depending on the orientation of the tabs.  Overlapping tabs for the selected
state are created by using negative margins or using the absolute position
scheme.  The tear indicator of the QTabBar is styled using the ::tear
subcontrol.  QTabBar used two QToolButtons for its scrollers that can be styled
using the QTabBar QToolButton selector. To specify the width of the scroll
button use the ::scroller subcontrol.  The alignment of the tabs within the
QTabBar is styled using the alignment property.  Warning: To change the position
of the QTabBar within a QTabWidget, use the tab-bar subcontrol (and set
subcontrol-position). */

/*QTabBar {
    background-color: green;
    color: yellow;
    font: bold;
}*/

/* pasted demo code -- QTabBar and QTabWidget are somewhat complicated to
style, rather like menus */

QTabWidget::pane { /* The tab widget frame */
    border-top: 2px solid #C2C7CB;
}

QTabWidget::tab-bar {
    left: 5px; /* move to the right by 5px */
}

/* Style the tab using the tab sub-control. Note that
    it reads QTabBar _not_ QTabWidget */
QTabBar::tab {
    background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
                                stop: 0 #E1E1E1, stop: 0.4 #DDDDDD,
                                stop: 0.5 #D8D8D8, stop: 1.0 #D3D3D3);
    border: 2px solid #C4C4C3;
    border-bottom-color: #C2C7CB; /* same as the pane color */
    border-top-left-radius: 4px;
    border-top-right-radius: 4px;
    min-width: 8ex;
    padding: 2px;
}

QTabBar::tab:selected, QTabBar::tab:hover {
    background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
                                stop: 0 #fafafa, stop: 0.4 #f4f4f4,
                                stop: 0.5 #e7e7e7, stop: 1.0 #fafafa);
}

QTabBar::tab:selected {
    border-color: #9B9B9B;
    border-bottom-color: #C2C7CB; /* same as pane color */
}

QTabBar::tab:!selected {
    margin-top: 2px; /* make non-selected tabs look smaller */
}


/*  QTabWidget

The frame of the tab widget is styled using the ::pane subcontrol. The left and
right corners are styled using the ::left-corner and ::right-corner
respectively. The position of the the tab bar is controlled using the ::tab-bar
subcontrol.  By default, the subcontrols have positions of a QTabWidget in the
QWindowsStyle. To place the QTabBar in the center, set the subcontrol-position
of the tab-bar subcontrol.  The :top, :left, :right, :bottom pseudo states
depending on the orientation of the tabs. */

/*QTabWidget {
    background-color: #000000;
    color: #FFFFFF;
}*/



/*   QTableView (affects QTableWidget)

Supports the box model. When alternating row colors is enabled, the alternating
colors can be styled using the alternate-background-color property.  The color
and background of the selected item is styled using selection-color and
selection-background-color respectively.  The corner widget in a QTableView is
implemented as a QAbstractButton and can be styled using the "QTableView
QTableCornerButton::section" selector.  The color of the grid can be specified
using the gridline-color property.  See QAbsractScrollArea to style scrollable
backgrounds. */

QTableView {
}


/*  QTextEdit

Supports the box model.  The color and background of selected text is styled
using selection-color and selection-background-color respectively.  See
QAbsractScrollArea to style scrollable backgrounds.  QTimeEdit   See QSpinBox. */

QTextEdit {
}


/* QToolBar

Supports the box model.  The :top, :left, :right, :bottom pseudo states
depending on the area in which the tool bar is grouped.  The :first, :last,
:middle, :only-one pseudo states indicator the position of the tool bar within a
line group (See QStyleOptionToolBar::positionWithinLine).  The separator of a
QToolBar is styled using the ::separator subcontrol.  The handle (to move the
toolbar) is styled using the ::handle subcontrol. */

QToolBar {
    background-color: #808080;
}

QToolBar::handle {
    image: url(toolbar-separator.png);
}



/*  QToolButton
  
Supports the box model.  If the QToolButton has a menu, is ::menu-indicator
subcontrol can be used to style the indicator. By default, the menu-indicator is
positioned at the bottom right of the Padding rectangle of the widget.  If the
QToolButton is in QToolButton::MenuButtonPopup mode, the ::menu-button
subcontrol is used to draw the menu button. ::menu-arrow subcontrol is used to
draw the menu arrow inside the menu-button. By default, it is positioned in the
center of the Contents rectangle of the the menu-button subcontrol.  When the
QToolButton displays arrows, the ::up-arrow, ::down-arrow, ::left-arrow and
::right-arrow subcontrols are used.  Warning: If you only set a background-color
on a QToolButton, the background will not appear unless you set the border
property to some value. This is because, by default, the QToolButton draws a
native border which completely overlaps the background-color. For example,
QToolButton { background-color: red; border: none; } */

QToolButton {
}


/*  QToolBox

Supports the box model.  The individual tabs can by styled using the ::tab
subcontrol. The tabs support the :only-one, :first, :last, :middle,
:previous-selected, :next-selected, :selected pseudo states. */

QToolBox {
}



/*  QToolTip

Supports the box model. The opacity property controls the opacity of the tooltip. */

QToolTip {
    background-color: red;
    color: yellow;
}


/*  QTreeView (affects QTreeWidget)

Supports the box model. When alternating row colors is enabled, the alternating
colors can be styled using the alternate-background-color property.  The color
and background of the selected item is styled using selection-color and
selection-background-color respectively.  The branches of the tree view can be
styled using the ::branch subcontrol. The ::branch Sub-control supports the
:open, :closed, :has-sibling and :has-children pseudo states.  See
QAbsractScrollArea to style scrollable backgrounds. */

QTreeView {
}


/*  QWidget

Supports only the background, backgorund-clip and background-origin properties.
If you subclass from QWidget, you need to provide a paintEvent for your custom
QWidget as below:

void CustomWidget::paintEvent(QPaintEvent *) {
     QStyleOption opt;
     opt.init(this);
     QPainter p(this);
     style()->drawPrimitive(QStyle::PE_Widget, &opt, &p, this);
}

The above code is a no-operation if there is no stylesheet set.
Warning: Make sure you define the Q_OBJECT macro for your custom widget. */

QWidget {
    /* We can't style QWidget without changing EVERYTHING, so we have to address
     * all our QWidget-derived widgets by name instead.  The Qt name property
     * turns out to be good for something after all, apparently. */
}

QWidget#TRACK_BUTTONS {
    background-color: yellow;
    color: white;
    selection-background-color: blue;
    selection-color: yellow;
}

QWidget#TRACK_LABEL {
    background-color: yellow;
    color: white;
    selection-background-color: blue;
    selection-color: yellow;
}

QWidget#ROTARY {
    background-color: transparent;
}

QWidget#LED {
    background-color: transparent;
}

QWidget#MATRIX {
    background-color: #000000;
}

/* the parameter area in the matrix views, I think */
QWidget#DOCK {
    background-color: #000000; 
}

/* the audio and MIDI mixer windows */
/* (actually only affects audio, because the MIDI mixer window is more
 * complicated) */
QWidget#MIXER_WINDOW {
    background-color: #000000; 
}

/* internal fader widgets need a style-set transparent background at a minimum */
QWidget#FADER {
    /* or maybe not...  this is actually too simplistic to work, and needs
     * further investigation */
    background-color: transparent;
}

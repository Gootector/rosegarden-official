#
# script generated by configure
# Sat Feb 12 10:53:35 2005
#

def exists():
	return True
def generate(env):

	#
	#code generated by module kde
	#

	def set_kde_env(env):
		env['KDEDIR']   ='/opt/kde3.3'
		env['QTDIR']    ='/opt/qt3.3'
		env['QT_UIC']   ='/opt/qt3.3/bin/uic'
		env['QT_MOC']   ='/opt/qt3.3/bin/moc'
		env['PREFIX']   ='/opt/kde3.3'
		env['KDEBIN']   ='/opt/kde3.3/bin'
		env['KDEAPPS']  ='/opt/kde3.3/share/applnk'
		env['KDEDATA']  ='/opt/kde3.3/share/apps'
		env['KDEMODULE']='/opt/kde3.3/lib/kde3'
		env['KDELOCALE']='/opt/kde3.3/share/locale'
		env['KDEDOC']   ='/opt/kde3.3/share/doc/HTML'
		env['KDEKCFG']  ='/opt/kde3.3/share/config.kcfg'
		env['KDEXDG']   ='/opt/kde3.3/share/applications/kde'
		env['KDEMENU']  ='/opt/kde3.3/share/applnk'
		env['KDEMIME']  ='/opt/kde3.3/share/mimelnk'
		env['KDEICONS'] ='/opt/kde3.3/share/icons'
		env['KDESERV']  ='/opt/kde3.3/share/services'
		env['QTPLUGINS']='/opt/kde3.3/lib/kde3/plugins'
	
	## includes and libraries
		env.Append(CXXFLAGS = ['-I/opt/kde3.3/include/'])
		env.Append(LIBPATH = ['/opt/kde3.3/lib'])
		env.Append(CXXFLAGS = ['-I/opt/qt3.3/include/'])
		env.Append(LIBPATH = ['/opt/qt3.3/lib'])
	import os.path
	import re
	import string
	
	import SCons.Defaults
	import SCons.Tool
	import SCons.Util
	
	#
	# Copyright (c) 2001, 2002, 2003, 2004 The SCons Foundation
	#
	# Permission is hereby granted, free of charge, to any person obtaining
	# a copy of this software and associated documentation files (the
	# "Software"), to deal in the Software without restriction, including
	# without limitation the rights to use, copy, modify, merge, publish,
	# distribute, sublicense, and/or sell copies of the Software, and to
	# permit persons to whom the Software is furnished to do so, subject to
	# the following conditions:
	#
	# The above copyright notice and this permission notice shall be included
	# in all copies or substantial portions of the Software.
	#
	# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
	# KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
	# WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
	# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
	# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	#
	
	# Taken from qt.py and modified into kde.py
	# Thomas Nagy, 2004 <tnagy2^8@yahoo.fr>
	
	"""
	we are NOT trying to detect kde or qt
	we just want the necessary rules for building kde programs
	"""
	
	ui_extensions = [".ui", ".Ui", ".UI"]
	header_extensions = [".h", ".hxx", ".hpp", ".hh", ".H", ".HH"]
	source_extensions = [".cpp", ".cxx", ".cc", ".CPP", ".CXX", ".CC"]
	
	def find_file(filename, paths, node_factory):
	    retval = None
	    for dir in paths:
	        node = node_factory(filename, dir)
	        if node.rexists():
	            return node
	    return None
	
	class _Metasources:
	    """
	    Callable class, which works as an emitter for Programs, SharedLibraries and
	    StaticLibraries.
	    """
	
	    def __init__(self, objBuilderName):
	        self.objBuilderName = objBuilderName
	
	    def __call__(self, target, source, env):
	        """
	        Smart autoscan function. Gets the list of objects for the Program
	        or Lib. Adds objects and builders for the special qt files.
	        """
	        try:
	            if int(env.subst('$QT_AUTOSCAN')) == 0:
	                return target, source
	        except ValueError:
	            pass
	
	        try:
	            qtdebug = int(env.subst('$QT_DEBUG'))
	        except ValueError:
	            qtdebug = 0
	
		try:
		    dcopdebug = int(env.subst('$DCOP_DEBUG'))
		except ValueError:
		    dcopdebug = 0
	
	        # some shortcuts used in the scanner
	        FS = SCons.Node.FS.default_fs
	        splitext = SCons.Util.splitext
	        objBuilder = getattr(env, self.objBuilderName)
	
	        # some regular expressions:
	        # Q_OBJECT detection
	        q_object_search = re.compile(r'[^A-Za-z0-9]Q_OBJECT[^A-Za-z0-9]')
	
		# K_DCOP detection
	        k_dcop_search = re.compile(r'[^A-Za-z0-9]K_DCOP[^A-Za-z0-9]')
	
	       # cxx and c comment 'eater'
	        #comment = re.compile(r'(//.*)|(/\*(([^*])|(\*[^/]))*\*/)')
	        # CW: something must be wrong with the regexp. See also bug #998222
	        #     CURRENTLY THERE IS NO TEST CASE FOR THAT
	
	        # The following is kind of hacky to get builders working properly (FIXME)
	        objBuilderEnv = objBuilder.env
	        objBuilder.env = env
	        mocBuilderEnv = env.Moc.env
	        env.Moc.env = env
	
	        # make a deep copy for the result; MocH objects will be appended
	        out_sources = source[:]
	
	        for obj in source:
	            if not obj.has_builder():
	                # binary obj file provided
	                if qtdebug or dcopdebug:
	                    print "scons: qt: '%s' seems to be a binary. Discarded." % str(obj)
	                continue
	            cpp = obj.sources[0]
	            if not splitext(str(cpp))[1] in source_extensions:
	                if qtdebug or dcopdebug:
	                    print "scons: qt: '%s' is no cxx file. Discarded." % str(cpp)
	                # c or fortran source
	                continue
	            #cpp_contents = comment.sub('', cpp.get_contents())
	            cpp_contents = cpp.get_contents()
	
	            h  = None
		    ui = None
	
	            for ui_ext in ui_extensions:
	                # try to find the ui file in the corresponding source directory
	                uiname = splitext(cpp.name)[0] + ui_ext
	                ui = find_file(uiname,
	                              (cpp.get_dir(),),
	                              FS.File)
	                if ui:
	                    if qtdebug:
	                        print "scons: qt: found .ui file of header" #% (str(h), str(cpp))
	                    #h_contents = comment.sub('', h.get_contents())
	                    break
	
		    # if we have a .ui file, do not continue, it is automatically handled by Uic
		    if ui:
			continue
	
	            for h_ext in header_extensions:
	                # try to find the header file in the corresponding source
	                # directory
	                hname = splitext(cpp.name)[0] + h_ext
	                h = find_file(hname,
	                              (cpp.get_dir(),),
	                              FS.File)
	                if h:
	                    if qtdebug:
	                        print "scons: qt: Scanning '%s' (header of '%s')" % (str(h), str(cpp))
	                    #h_contents = comment.sub('', h.get_contents())
	                    h_contents = h.get_contents()
	                    break
	
	            if not h and (qtdebug or dcopdebug):
	                print "scons: qt: no header for '%s'." % (str(cpp))
	            if h and q_object_search.search(h_contents):
	                # h file with the Q_OBJECT macro found -> add moc file
	                moc_cpp = env.Moc(h)
			#moc_o = objBuilder(moc_cpp)
			#out_sources.append(moc_o)
	                #moc_cpp.target_scanner = SCons.Defaults.CScan
	                if qtdebug:
	                    print "scons: qt: found Q_OBJECT macro in '%s', moc'ing to '%s'" % (str(h), str(moc_cpp[0]))
	
	            if h and k_dcop_search.search(h_contents):
	                # h file with the K_DCOP macro found -> add dcop file
	                dcop_cpp = env.Dcop(h)
			dcop_o = objBuilder(dcop_cpp[0])
			out_sources.append(dcop_o)
	                if dcopdebug:
	                    print "scons: qt dcop: found K_DCOP macro in '%s', dcop'ing to '%s'" % (str(h), str(dcop_cpp[0]))
	
	            if cpp and q_object_search.search(cpp_contents):
	                # cpp file with Q_OBJECT macro found -> add moc
	                # (to be included in cpp)
	                moc = env.Moc(cpp)
	                env.Ignore(moc, moc)
	                if qtdebug:
	                    print "scons: qt: found Q_OBJECT macro in '%s', moc'ing to '%s'" % (str(cpp), str(moc[0]))
	                #moc.source_scanner = SCons.Defaults.CScan
	        # restore the original env attributes (FIXME)
	        objBuilder.env = objBuilderEnv
	        env.Moc.env = mocBuilderEnv
	
	        return (target, out_sources)
	
	MetasourcesShared = _Metasources('SharedObject')
	MetasourcesStatic = _Metasources('StaticObject')
	
	CLVar = SCons.Util.CLVar
	splitext = SCons.Util.splitext
	Builder = SCons.Builder.Builder
	
	set_kde_env(env)
	
	env['STATIC_AND_SHARED_OBJECTS_ARE_THE_SAME'] = 1
	
	env['QT_AUTOSCAN']     = 1
	env['QT_DEBUG']        = 0
	env['DCOP_AUTOSCAN']   = 1
	env['DCOP_DEBUG']      = 0
	
	env['QT_UIC_HFLAGS']   = '-L $QTPLUGINS -nounload'
	env['QT_UIC_CFLAGS']   = '$QT_UIC_HFLAGS -tr tr2i18n'
	env['QT_LIBS']         = 'qt-mt'
	
	env['LIBTOOL_FLAGS']   = '--silent --mode=compile --tag=CXX'
	
	env['QT_UICIMPLPREFIX'] = ''
	env['QT_UICIMPLSUFFIX'] = '.cpp'
	env['QT_MOCHPREFIX']    = ''
	env['QT_MOCHSUFFIX']    = '.moc'
	env['KDE_KCFG_IMPLPREFIX'] = ''
	env['KDE_KCFG_IMPL_HSUFFIX'] = '.h'
	env['KDE_KCFG_IMPL_CSUFFIX'] = '.cpp'
	
	env['MEINPROC']              = 'meinproc'
	env['MSGFMT']                = 'msgfmt'
	
	###### ui file processing
	
	def uicGenerator(target, source, env, for_signature):
	    act=[]
	    act.append('$QT_UIC $QT_UIC_HFLAGS -o '+target[0].path+' '+source[0].path)
	    act.append('rm -f '                           +target[1].path)
	    act.append('echo \'#include <klocale.h>\' >> '+target[1].path)
	    act.append('echo \'#include <kdialog.h>\' >> '+target[1].path)
	    act.append('$QT_UIC $QT_UIC_CFLAGS -impl '+target[0].path+' -o '+target[1].path+'.tmp '+source[0].path)
	    act.append('cat '+target[1].path+'.tmp >> '+target[1].path)
	    act.append('rm -f '+target[1].path+'.tmp')
	    act.append('echo \'#include "' + target[2].name + '"\' >> '+target[1].path)
	    act.append('$QT_MOC -o '+target[2].path+' '+target[0].path)
	    return act
	
	def uicEmitter(target, source, env):
	    adjustixes = SCons.Util.adjustixes
	    bs = SCons.Util.splitext(str(source[0].name))[0]
	    bs = os.path.join(str(target[0].get_dir()),bs)
	    # first target is automatically added by builder (.h file)
	    if len(target) < 2:
	        # second target is .cpp file
	        target.append(adjustixes(bs,
	            env.subst('$QT_UICIMPLPREFIX'),
	            env.subst('$QT_UICIMPLSUFFIX')))
	    if len(target) < 3:
	        # third target is .moc file
	        target.append(adjustixes(bs,
	            env.subst('$QT_MOCHPREFIX'),
	            env.subst('$QT_MOCHSUFFIX')))
	    return target, source
	
	UIC_BUILDER = Builder(
	    generator       = uicGenerator,
	    emitter         = uicEmitter,
	    suffix          = '.h',
	    src_suffix      = '.ui' )
	
	###### moc file processing
	env['QT_MOCCOM'] = ('$QT_MOC -o ${TARGETS[0]} $SOURCE')
	
	def mocEmitter(target, source, env):
	    adjustixes = SCons.Util.adjustixes
	    bs = SCons.Util.splitext(str(source[0].name))[0]
	    bs = os.path.join(str(target[0].get_dir()),bs)
	    # first target (header) is automatically added by builder
	    if len(target) < 2:
	        # third target is moc file
	        target.append(adjustixes(bs,
	            env.subst('$QT_MOCHPREFIX'),
	            env.subst('$QT_MOCHSUFFIX')))
	    return target, source
	
	MOC_BUILDER = Builder(
	    action          = '$QT_MOCCOM',
	    #emitter         = mocEmitter,
	    suffix          = '.moc',
	    src_suffix      = '.h' )
	
	###### kcfg file processing
	def kcfgGenerator(target, source, env, for_signature):
	    act=[]
	    act.append('kconfig_compiler -d'+str(source[0].get_dir())+' '+source[1].path+' '+source[0].path)
	    return act
	
	def kcfgEmitter(target, source, env):
	    adjustixes = SCons.Util.adjustixes
	    bs = SCons.Util.splitext(str(source[0].name))[0]
	    bs = os.path.join(str(target[0].get_dir()),bs)
	    # first target is automatically added by builder (.h file)
	    if len(target) < 2:
	        # second target is .cpp file
	        target.append(adjustixes(bs,
	            env.subst('$KDE_KCFG_IMPLPREFIX'),
	            env.subst('$KDE_KCFG_IMPL_CSUFFIX')))
	
	    #    find_file(kcfgfile, (source[0].get_dir(),) ,SCons.Node.FS.default_fs)
	    if len(source) <2:
	        kcfgfilename = os.popen("cat "+source[0].name+"|grep File|sed 's/File.*=//i'").read().rstrip()
	        source.append( kcfgfilename )
	
	    return target, source
	
	KCFG_BUILDER = Builder(
	    generator       = kcfgGenerator,
	    emitter         = kcfgEmitter,
	    suffix          = '.h',
	    src_suffix      = '.kcfgc' )
	
	###### dcop processing
	def dcopGenerator(target, source, env, for_signature):
	    act=[]
	    act.append('dcopidl '+source[0].path+' > '+target[1].path+'|| ( rm -f '+target[1].path+' ; false )')
	    act.append('dcopidl2cpp --c++-suffix cpp --no-signals --no-stub '+target[1].path)
	    return act
	
	def dcopEmitter(target, source, env):
	    bs = SCons.Util.splitext(str(source[0].name))[0]
	    bs = os.path.join(str(target[0].get_dir()),bs)
	
	    target.append(bs+'.kidl')
	    #target.append(bs+'_skel.cpp')
	
	    #if len(target) <2:
	    #    target.append(bs+'.kidl')
	
	    return target, source
	
	DCOP_BUILDER = Builder(
	    generator       = dcopGenerator,
	    emitter         = dcopEmitter,
	    suffix          = '_skel.cpp',
	    src_suffix      = '.h' )
	
	###### documentation (meinproc) processing
	MEINPROC_BUILDER = Builder(
	    action          = '$MEINPROC --check --cache $TARGET $SOURCE',
	    suffix          = '.cache.bz2',
	    src_suffix      = '.docbook' )
	
	###### translation files builder
	TRANSFILES_BUILDER = Builder(
	    action          = '$MSGFMT $SOURCE -o $TARGET',
	    suffix          = '.gmo',
	    src_suffix      = '.po' )
	
	###### libtool file builder
	def laGenerator(target, source, env, for_signature):
	    act=[]
	    act.append('echo "dlname=\''+source[0].name+'\'" > '+target[0].path)
	    act.append('echo "library_names=\''+source[0].name+' '+source[0].name+' '+source[0].name+'\'" >> '+target[0].path)
	    act.append('echo "old_library=\'\'"     >> '+target[0].path)
	    act.append('echo "dependency_libs=\'\'" >> '+target[0].path)
	    act.append('echo "current=0"            >> '+target[0].path)
	    act.append('echo "age=0"                >> '+target[0].path)
	    act.append('echo "revision=0"           >> '+target[0].path)
	    act.append('echo "installed=yes"        >> '+target[0].path)
	    act.append('echo "shouldnotlink=no"     >> '+target[0].path)
	    act.append('echo "dlopen=\'\'"          >> '+target[0].path)
	    act.append('echo "dlpreopen=\'\'"       >> '+target[0].path)
	    act.append('echo "libdir=\''+env['KDEMODULE']+'\'" >> '+target[0].path)
	    return act
	
	LA_BUILDER = Builder(
	    generator       = laGenerator,
	    suffix          = '.la',
	    src_suffix      = '.so' )
	
	####### real libtool builder
	#    def libtoolGenerator(target, source, env, for_signature):
	#        act=[]
	#        act.append('libtool $LIBTOOL_FLAGS $CXX $CXXFLAGS $CPPFLAGS $_CPPDEFFLAGS $_CPPINCFLAGS -c -o '+target[0].path+' '+source[0].path)
	#        return act
	
	#    LIBTOOL_BUILDER = Builder(
	#        generator       = libtoolGenerator,
	#        suffix          = '.lo',
	#        src_suffix      = '.cpp' )
	
	##### register the builders
	env['BUILDERS']['Uic']        = UIC_BUILDER
	env['BUILDERS']['Moc']        = MOC_BUILDER
	env['BUILDERS']['Dcop']       = DCOP_BUILDER
	env['BUILDERS']['Kcfg']       = KCFG_BUILDER
	env['BUILDERS']['LaFile']     = LA_BUILDER
	#env['BUILDERS']['Libtool']    = LIBTOOL_BUILDER
	env['BUILDERS']['Meinproc']   = MEINPROC_BUILDER
	env['BUILDERS']['Transfiles'] = TRANSFILES_BUILDER
	
	static_obj, shared_obj = SCons.Tool.createObjBuilders(env)
	static_obj.src_builder.append('Uic')
	shared_obj.src_builder.append('Uic')
	static_obj.src_builder.append('Kcfg')
	shared_obj.src_builder.append('Kcfg')
	static_obj.src_builder.append('LaFile')
	shared_obj.src_builder.append('LaFile')
	static_obj.src_builder.append('Meinproc')
	shared_obj.src_builder.append('Meinproc')
	static_obj.src_builder.append('Transfiles')
	shared_obj.src_builder.append('Transfiles')
	
	## find the files to moc, dcop, and link against kde and qt
	env.AppendUnique(PROGEMITTER =[MetasourcesStatic],
	                SHLIBEMITTER=[MetasourcesShared],
	                LIBEMITTER  =[MetasourcesStatic])

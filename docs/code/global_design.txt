
Rosegarden-4 global design
==========================

Rosegarden is split into 3 main parts:

----------------------------------------------------------------------

BASE
----

The base library holds all of the fundamental "music handling"
structures, of which the primary ones are Event, Segment, Track,
Instrument and Composition.  It also contains a selection of utility
and helper classes of a kind that is not specific to any particular
GUI.  Everything here is part of the Rosegarden namespace, and there
are no dependencies on KDE or Qt (although it uses the STL heavily).

 -- Event is the basic musical element.  It's more or less a
 generalization of the MIDI event.  Each note or rest is an event;
 each key change or tempo change is an event; etc, etc.  Functionally,
 an Event is an association of a type code, absolute time (the moment
 at which the Event starts, relative only to the start of the
 Composition) and duration (usually non-zero only for notes and rests)
 with an arbitrary set of named and typed properties that can be
 assigned and queried dynamically by other parts of the application.

 -- Segment is a series of consecutive Events found on the same Track,
 automatically ordered by their absolute time.  It's the usual
 container for Events.  A Segment has a starting time that can be
 changed, and a duration that is based solely on the end time of the
 last Event it contains.  Note that in order to facilitate musical
 notation editing, we explicitly store silences as series of rest
 Events; thus a Segment really should contain no gaps between its
 Events.  (This isn't checked anywhere and nothing will break very
 badly if there are gaps, but notation won't quite work correctly.)

 -- Track is the much same thing as on a mixing table, usually
 assigned to an instrument, a voice, etc.  Although a Track is _not_ a
 container of Events, it is referred to by a set of Segments that are
 therefore mutually associated with the same instruments and
 parameters.  In GUI terms, the Track is a horizontal row on the main
 Rosegarden window, whereas a Segment is a single blue box within that
 row, of which there may be any number.

 -- Instrument corresponds broadly to a MIDI channel, and is the
 destination for a performed Event.  Each Track is mapped to a single
 Instrument (although many Tracks may have the same Instrument), and
 the instrument is indicated in the header at the left of the Track's
 row in the GUI.

 -- Composition is the container for the entire piece of music.  It
 consists of a set of Segments, together with a set of Tracks that the
 Segments may or may not be associated with, a set of Instruments, and
 some information about time signature and tempo changes.  (The latter
 are not stored in Segments; they are only stored in the top-level
 Composition.  You can't have differing time signatures or tempos in
 different Segments.)  Any code that wants to know about the locations
 of bar lines, or request real-time calculations based on tempo
 changes, talks to the Composition.

See also docs/data_struct/units.txt for an explanation of the units we
use for time and pitch values.  See docs/discussion/names.txt for some
name-related discussion.

----------------------------------------------------------------------

GUI
---

The GUI directory builds into a KDE/Qt application. Like most KDE
applications, it follows a document/view model. The document (class
RosegardenGUIDoc, which wraps a Composition) can have several views
(class RosegardenGUIView), although at the moment only a single one is
used.

This view is the TrackEditor, which shows all the Composition's
Segments organized in Tracks. Each Segment can be edited in two ways:
notation (score) or matrix (piano roll).

All editor views are derived from EditView. An EditView is the class
dealing with the edition per se of the events. It uses several
components:

 -- Layout classes, horizontal and vertical: these are the classes
 which determine the x and y coordinates of the graphic items
 representing the events (notes or piano-roll rectangles).  They are
 derived from the LayoutEngine base-class in the base library.

 -- Tools, which implement each editing function at the GUI (such as
 insert, erase, cut and paste). These are the tools which appear on
 the EditView's toolbar.

 -- Toolbox, which is a simple string => tool map.

 -- Commands, which are the fundamental implementations of editing
 operations (both menu functions and tool operations) subclassed from
 KDE's KCommand and used for undo and redo.

 -- a canvas view.  Although this isn't a part of the EditView's
 definition, both of the existing edit views (notation and matrix) use
 one, because they both use a QCanvas to represent data.

 -- LinedStaff, a staff with lines.  Like the canvas view, this isn't
 part of the EditView definition, but both views use one.


There are currently two editor views:

 -- NotationView, with accompanying classes NotationHLayout,
 NotationVLayout, NotationStaff, and all the classes in the
 notationtool and notationcommands files.  These are also closely
 associated with the NotePixmapFactory and NoteFont classes, which are
 used to generate notes from component pixmap files.

 -- MatrixView, with accompanying classes MatrixHLayout,
 MatrixVLayout, MatrixStaff and other classes in the matrixview files.


NOTE : in the following, we're talking both about events as UI events
or user events (mouse button clicks, mouse move, keystrokes, etc...)
and Events (our basic music element).  To help lift the ambiguity,
"events" is for UI events, Events is for Rosegarden::Event.

The editing process works as follows : 

1. The canvas view gets the user events (see
NotationCanvasView::contentsMousePressEvent(QMouseEvent*) for an
example).  It locates where the event occured in terms of musical
element: which note or staff line the user clicked on, which pitch and
time this corresponds to, that kind of stuff.  (In the Notation and
Matrix views, the LinedStaff calculates mappings between coordinates
and staff lines: the former is especially complicated because of its
support for page layout.)

2. The canvas view transmits this kind of info as a signal, which is
connected to a slot in the parent EditView.

3. The EditView delegates action to the current tool.

4. The tool performs the actual job (inserting or deleting a note,
etc...).

Since this action is usually complex (merely inserting a note requires
dealing with the surrounding Events, rests or notes), it does it
through a SegmentHelper (for instance, base/SegmentNotationHelper)
which "wraps" the complexity into simple calls and performs all the
hidden tasks.

The EditView also maintains (obviously) its visual appearance with the
layout classes, applying them when appropriate.

----------------------------------------------------------------------

SEQUENCER
---------

The sequencer directory also builds into a KDE/Qt application, but one
which doesn't have a GUI.  It runs invisibly, communicating with the
main GUI through DCOP, and sends music events to aRTS.


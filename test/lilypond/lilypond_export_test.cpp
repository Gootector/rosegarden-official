/* -*- c-basic-offset: 4 indent-tabs-mode: nil -*- vi:set ts=8 sts=4 sw=4: */

#include "base/NotationTypes.h"
#include "document/io/LilyPondExporter.h"
#include "document/RosegardenDocument.h"
#include "misc/ConfigGroups.h"

#include <QTest>
#include <QDebug>
#include <QProcess>
#include <QSettings>

using namespace Rosegarden;

// Unit test for lilypond export

class TestLilypondExport : public QObject
{
    Q_OBJECT

private Q_SLOTS:
    // QTest special functions...
    // Called once.
    void initTestCase();
    // Called before every test.
    void init();

    // Our test functions.
    void testEmptyDocument();

    // Data-driven testing against the example .rg files.
    // https://doc.qt.io/qt-5/qttestlib-tutorial2-example.html
    // Generate the test data.
    void testExamples_data();
    // Called for each row of test data.
    void testExamples();
};

void TestLilypondExport::initTestCase()
{
    // We certainly don't want to mess up the user's QSettings or allow
    // the user's QSettings to affect the tests.  Use a separate file.
    QCoreApplication::setApplicationName("test_lilypond_export");
}

void TestLilypondExport::init()
{
    // Change the settings so that they are consistent and not affected
    // by defaults.
    // ??? Can't we move this to initTestCase() and get the same effect?
    //     I don't think we need to be doing this for every test case.
    QSettings settings;
    settings.beginGroup(LilyPondExportConfigGroup);
    settings.setValue("lilyfontsize", 12); // the default of 26 is really huge!
    settings.setValue("lilyexportbeamings", false);
    settings.endGroup();
}

// Read an entire file line-by-line.
// This is used by checkFile() to read the expected file and the
// actual file for comparison.
QList<QByteArray> readLines(const QString &fileName)
{
    QList<QByteArray> lines;
    QFile file(fileName);
    if (!file.open(QIODevice::ReadOnly)) {
        qWarning() << "Couldn't open" << fileName;
    } else {
        while (!file.atEnd()) {
            lines.append(file.readLine());
        }
    }
    return lines;
}

const char header1[] =
        "This LilyPond file was generated by Rosegarden";
const char header2[] =
        "Created using Rosegarden ";

// Check the generated file (fileName) against the baseline file.
void checkFile(const QString &fileName, const QString &baseline)
{
    // Read in the files.
    const QList<QByteArray> expected = readLines(baseline);
    QList<QByteArray> actual = readLines(fileName);
    
    // For each line in the files...
    for (int i = 0; i < expected.count() && i < actual.count(); ++i) {
        const QByteArray line = actual.at(i);
        const QByteArray expectedLine = expected.at(i);
        
        // Skip header lines which have rosegarden versions in them.
        if (line.contains(header1) &&
                expectedLine.contains(header1))
            continue;
        if (line.contains(header2) &&
                expectedLine.contains(header2))
            continue;
        
        // Compare the remaining lines.
        QCOMPARE(QString(line), QString(expectedLine));
    }
    
    // Make sure the same number of lines were compared.
    QCOMPARE(actual.count(), expected.count());

    // All good, clean up
    QFile::remove(fileName);
}

void TestLilypondExport::testEmptyDocument()
{
    // GIVEN a document and a lilypond exporter
    RosegardenDocument doc(nullptr, {}, true /*skip autoload*/, true, false /*no sound*/);
    const QString fileName = "out.ly";
    LilyPondExporter exporter(&doc, SegmentSelection(), qstrtostr(fileName));

    // WHEN generating lilypond
    bool result = exporter.write();

    // THEN it should produce the file but return false and a warning message
    QVERIFY(!result);
    QCOMPARE(exporter.getMessage(), QString("Export succeeded, but the composition was empty."));

    // ... and the output file should match "empty.ly"
    checkFile(fileName, QFINDTESTDATA("baseline/empty.ly"));
}

// ??? Why do we have this?  We never use anything other than
//     ExportBeaming.  This can be removed.
enum Option {
    NoOptions = 0,
    ExportBeaming
};
Q_DECLARE_FLAGS(Options, Option)
Q_DECLARE_OPERATORS_FOR_FLAGS(Options)
Q_DECLARE_METATYPE(Options)
Options defaultOptions(ExportBeaming);

void TestLilypondExport::testExamples_data()
{
    // Usually "examples", but one "regression".
    QTest::addColumn<QString>("baseDir");

    QTest::newRow("aveverum") << "examples";
    QTest::newRow("aylindaamiga") << "examples";
    QTest::newRow("bogus-surf-jam") << "examples";
    QTest::newRow("beaming") << "examples";
    QTest::newRow("Brandenburg_No3-BWV_1048") << "examples";
    QTest::newRow("bwv-1060-trumpet-duet-excerpt") << "examples";

    // Those work but are very slow, and they output lots and lots of
    // WARNING: Rosegarden::Exception: "Bad type for Indication model event
    //          (expected indication, found controller)"
    //QTest::newRow("children") << "examples";
    //QTest::newRow("Chopin-Prelude-in-E-minor-Aere") << "examples";

    QTest::newRow("Djer-Fire") << "examples";
    QTest::newRow("doodle-q") << "examples";
    QTest::newRow("exercise_notation") << "examples";
    QTest::newRow("glazunov-for-solo-and-piano-with-cue") << "examples";
    QTest::newRow("glazunov") << "examples";
    QTest::newRow("Hallelujah_Chorus_from_Messiah") << "examples";
    QTest::newRow("headers-and-unicode-lyrics") << "examples";
    QTest::newRow("himno_de_riego") << "examples";
    QTest::newRow("interpretation-example") << "examples";
    QTest::newRow("let-all-mortal-flesh") << "examples";
    QTest::newRow("lilypond-alternative-endings_new-way") << "examples";
    QTest::newRow("lilypond-alternative-endings") << "examples";
    QTest::newRow("lilypond-directives") << "examples";
    QTest::newRow("lilypond-up-down") << "examples";
    QTest::newRow("lilypond-staff-groupings") << "examples";
    QTest::newRow("lilypond-tied-grace-notes") << "examples";
    QTest::newRow("logical-segments-4") << "examples";
    QTest::newRow("mandolin-sonatina") << "examples";
    QTest::newRow("marks-test") << "examples";
    QTest::newRow("mozart-quartet") << "examples";
    QTest::newRow("notation-for-string-orchestra-in-D-minor") << "examples";
    QTest::newRow("perfect-moment") << "examples";
    QTest::newRow("ravel-pc-gmaj-adagio") << "examples";
    QTest::newRow("Romanza") << "examples";

    // THIS ONE FAILS
    // sicut-locutus.ly:98:47: error: syntax error, unexpected '}'
    //                < f g > 2 _\markup { \italic
    //                                              } _\markup { \italic Masked and substituted }  _~ f _~  |
    //QTest::newRow("sicut-locutus") << "examples";

    QTest::newRow("stormy-riders") << "examples";
    QTest::newRow("test_tuplets") << "examples";
    QTest::newRow("the-rose-garden") << "examples";
    QTest::newRow("vivaldi-cs3mv2") << "examples";
    QTest::newRow("vivaldi_op44_11_1") << "examples";

    // data/regression
    QTest::newRow("export_hidden_key_signatures") << "regression";
}

void TestLilypondExport::testExamples()
{
    QString baseName{QTest::currentDataTag()};
    QFETCH(QString, baseDir);

    // GIVEN
    const QString input = QFINDTESTDATA("../../data/" + baseDir + "/" + baseName + ".rg");
    QVERIFY(!input.isEmpty()); // file not found
    const QString expected = QFINDTESTDATA("baseline/" + baseName + ".ly");

    const QString fileName = baseName + ".ly";
    qDebug() << "Loading" << input << "and exporting to" << fileName;

    // ??? Again, why over and over.  Why not just at init?
    QSettings settings;
    settings.beginGroup(LilyPondExportConfigGroup);
    settings.setValue("lilyexportbeamings", true);
    settings.endGroup();

    RosegardenDocument doc(nullptr, {}, true /*skip autoload*/, true, false /*no sequencer*/);
    doc.openDocument(input, false /*not permanent, i.e. don't create midi devices*/, true /*no progress dlg*/);
    LilyPondExporter exporter(&doc, SegmentSelection(), qstrtostr(fileName));

    // WHEN
    QVERIFY(exporter.write());

    // THEN
    if (expected.isEmpty()) {
        // No baseline yet.

        // Use lilypond to check this file compiles before we add it to our baseline
        QProcess proc;
        proc.start("lilypond", QStringList() << "--ps" << fileName);
        proc.waitForStarted();
        proc.waitForFinished();
        QCOMPARE(proc.exitStatus(), QProcess::NormalExit);
        if (proc.exitCode() != 0) {
            qWarning() << "Generated file" << fileName << "does NOT compile!";
        }

        qWarning() << "*********** GENERATING NEW BASELINE FILE (remember to add it to SVN) ***********";
        QFile in(fileName);
        QVERIFY(in.open(QIODevice::ReadOnly));
        QFile out(QFile::decodeName(SRCDIR) + "/baseline/" + baseName + ".ly");
        QVERIFY(!out.exists());
        QVERIFY(out.open(QIODevice::WriteOnly));
        while (!in.atEnd()) {
            out.write(in.readLine());
        }
        QVERIFY(false); // make the test fail, so developers add the baseline to SVN and try again
    }

    // Compare generated file with expected file
    checkFile(fileName, expected);
}

QTEST_MAIN(TestLilypondExport)

#include "lilypond_export_test.moc"
